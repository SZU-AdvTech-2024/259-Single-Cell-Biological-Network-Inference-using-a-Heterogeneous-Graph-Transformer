import torchimport torch.nn as nnimport torch.nn.functional as Fimport mathclass GNN(nn.Module):    def __init__(self, in_dim, n_hid, num_types, num_relations, n_heads, n_layers, dropout=0.2, conv_name='hgt',                 prev_norm=True, last_norm=True, use_RTE=True):        super(GNN, self).__init__()        self.gcs = nn.ModuleList()        self.num_types = num_types        self.in_dim = in_dim        self.n_hid = n_hid        self.adapt_ws = nn.ModuleList()        self.drop = nn.Dropout(dropout)        self.att = None        self.emb = None        self.conv_name = conv_name        # 添加类型感知嵌入层        self.cell_embedding = nn.Embedding(in_dim[0], n_hid)  # 假设细胞的特征维度为 in_dim[0]        self.gene_embedding = nn.Embedding(in_dim[1], n_hid)  # 假设基因的特征维度为 in_dim[1]        # 为边类型定义嵌入层，边特征可以包含权重、关系类型等信息        self.edge_embedding = nn.ModuleList([nn.Embedding(in_dim[2], n_hid) for _ in                                             range(num_relations)])  # 假设边的关系维度为 in_dim[2]，num_relations 表示边的类型数量        for t in range(num_types):            self.adapt_ws.append(nn.Linear(n_hid, n_hid))        # 构建图卷积层        for l in range(n_layers - 1):            self.gcs.append(                GeneralConv(conv_name, n_hid, n_hid, num_types, num_relations, n_heads, dropout, use_norm=prev_norm,                            use_RTE=use_RTE))        self.gcs.append(            GeneralConv(conv_name, n_hid, n_hid, num_types, num_relations, n_heads, dropout, use_norm=last_norm,                        use_RTE=use_RTE))    def forward(self, node_feature, node_type, edge_time, edge_index, edge_type):        # 分别为细胞、基因和边进行嵌入        cell_emb = self.cell_embedding(node_feature[0])  # 假设 node_feature[0] 是细胞节点的特征        gene_emb = self.gene_embedding(node_feature[1])  # 假设 node_feature[1] 是基因节点的特征        # 处理边特征：将每种边类型的特征嵌入        edge_embs = [self.edge_embedding[t](edge_type == t) for t in range(len(self.edge_embedding))]        edge_emb = torch.stack(edge_embs, dim=0)  # 将每种边类型的嵌入堆叠起来        # 将这些嵌入结合在一起作为节点的输入特征        node_emb = cell_emb + gene_emb  # 你可以选择加和或拼接        # 为每个节点类型进行适配        res = torch.zeros(node_emb.size(0), self.n_hid).to(node_feature[0].device)        for t_id in range(self.num_types):            idx = (node_type == int(t_id))            if idx.sum() == 0:                continue            res[idx] = torch.tanh(self.adapt_ws[t_id](node_emb[idx]))        # 经过图卷积层        meta_xs = self.drop(res)        del res        # 在这里修改图卷积层，传入边的特征        for gc in self.gcs:            meta_xs = gc(meta_xs, node_type, edge_index, edge_type, edge_time, edge_emb)  # 将边嵌入传入图卷积层        if self.conv_name == 'hgt':            self.att = gc.res_att        return meta_xs  # 返回最终的节点表示